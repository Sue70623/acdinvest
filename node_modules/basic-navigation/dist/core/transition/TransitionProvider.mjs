import { jsx as H } from "react/jsx-runtime";
import { useReducer as V, useContext as C, useState as G, useRef as U, useEffect as E } from "react";
import K from "../activity/ActivityContext.mjs";
import { ActivityActionType as c } from "../activity/typing.mjs";
import d from "../history/HistoryContext.mjs";
import { HistoryActionType as f } from "../history/typing.mjs";
import v from "../navigation/NavigationContext.mjs";
import { NavigationStatus as h, NavigationActionType as s } from "../navigation/typing.mjs";
import { transitionReducer as x } from "./store.mjs";
import O from "./TransitionContext.mjs";
import { TransitionStatus as Y } from "./typing.mjs";
function J({ children: N }) {
  const [R, S] = V(x, {
    status: Y.DONE
  }), {
    state: { records: _ },
    dispatch: u
  } = C(d), { dispatch: o } = C(K), {
    state: { events: I },
    dispatch: i
  } = C(v), [y, T] = G([]), m = U(null), r = U(!1);
  return E(() => {
    if (!r.current)
      for (const t of I) {
        const n = `${t.path}-${t.status}-${t.recordedAt}`;
        t.status === h.PUSH ? (i({
          type: s.PUSH_NAVIGATING
        }), u({
          type: f.PUSH,
          path: t.path,
          params: t.params,
          animate: t.animate
        }), o({
          type: c.UPDATE_CURRENT_ACTIVITY,
          path: t.path,
          params: t.params,
          animate: t.animate
        }), T((a) => {
          if (r.current)
            return a.filter((e) => e.id !== n);
          r.current = !0;
          const p = () => new Promise((e) => {
            m.current = setTimeout(() => {
              i({
                type: s.PUSH_DONE
              }), e(!0);
            }, 300);
          });
          return a.concat({
            id: n,
            flush: p
          });
        })) : t.status === h.STACK_PUSH ? (i({
          type: s.STACK_PUSH_NAVIGATING
        }), u({
          type: f.STACK_PUSH,
          path: t.path,
          params: t.params,
          animate: t.animate
        }), o({
          type: c.UPDATE_CURRENT_ACTIVITY,
          path: t.path,
          params: t.params,
          animate: t.animate
        }), T((a) => {
          if (r.current)
            return a.filter((e) => e.id !== n);
          r.current = !0;
          const p = () => new Promise((e) => {
            m.current = setTimeout(() => {
              i({
                type: s.STACK_PUSH_DONE
              }), e(!0);
            }, 300);
          });
          return a.concat({
            id: n,
            flush: p
          });
        })) : t.status === h.REPLACE ? (i({
          type: s.REPLACE_NAVIGATING
        }), u({
          type: f.PUSH,
          path: t.path,
          params: t.params,
          animate: t.animate
        }), o({
          type: c.UPDATE_CURRENT_ACTIVITY,
          path: t.path,
          params: t.params,
          animate: t.animate
        }), T((a) => {
          if (r.current)
            return a.filter((e) => e.id !== n);
          r.current = !0;
          const p = (e) => new Promise((l) => {
            m.current = setTimeout(() => {
              const { path: A, params: P } = e[e.length - 3] || e[e.length - 2] || e[e.length - 1];
              o({
                type: c.UPDATE_SPECIFY_PREVIOUS_ACTIVITY,
                path: A,
                params: P
              }), i({
                type: s.REPLACE_DONE
              }), u({
                type: f.REPLACE,
                path: t.path,
                params: t.params,
                animate: t.animate
              }), l(!0);
            }, 300);
          });
          return a.concat({
            id: n,
            flush: p
          });
        })) : t.status === h.BACK && (i({
          type: s.BACK_NAVIGATING
        }), T((a) => {
          if (r.current)
            return a.filter((e) => e.id !== n);
          r.current = !0;
          const p = (e) => new Promise((l) => {
            const A = e[e.length - 1];
            A.type !== f.STACK_PUSH && o({
              type: c.UPDATE_WAITING_ACTIVITY
            }), m.current = setTimeout(() => {
              const { path: P, params: D, animate: g } = e[e.length - 3] || e[e.length - 2] || A;
              o({
                type: c.UPDATE_PREVIOUS_ACTIVITY,
                path: P,
                params: D,
                animate: g
              }), i({
                type: s.BACK_DONE
              }), u({ type: f.BACK }), l(!0);
            }, 300);
          });
          return a.concat({
            id: n,
            flush: p
          });
        }));
      }
  }, [I, o, i, u]), E(() => {
    y.length !== 0 && (async () => {
      for (const { flush: t } of y)
        await t(_) && (T((n) => n.slice(1)), r.current = !1);
    })();
  }, [y, _]), E(() => () => {
    m.current && clearTimeout(m.current);
  }, []), /* @__PURE__ */ H(O.Provider, { value: { state: R, dispatch: S }, children: N });
}
export {
  J as default
};
